import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/.pnpm/@shopify+draggable@1.0.0-beta.8/node_modules/@shopify/draggable/lib/draggable.bundle.js
var require_draggable_bundle = __commonJS({
  "node_modules/.pnpm/@shopify+draggable@1.0.0-beta.8/node_modules/@shopify/draggable/lib/draggable.bundle.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Draggable", [], factory);
      else if (typeof exports === "object")
        exports["Draggable"] = factory();
      else
        root["Draggable"] = factory();
    })(window, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 66);
      }([
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _AbstractEvent = __webpack_require__(64);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _AbstractEvent2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _AbstractPlugin = __webpack_require__(60);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _AbstractPlugin2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _closest = __webpack_require__(51);
          Object.defineProperty(exports2, "closest", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_closest).default;
            }
          });
          var _requestNextAnimationFrame = __webpack_require__(49);
          Object.defineProperty(exports2, "requestNextAnimationFrame", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_requestNextAnimationFrame).default;
            }
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SensorEvent = __webpack_require__(44);
          Object.keys(_SensorEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SensorEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Sensor = __webpack_require__(47);
          var _Sensor2 = _interopRequireDefault(_Sensor);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Sensor2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DragEvent = __webpack_require__(14);
          Object.keys(_DragEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DragEvent[key];
              }
            });
          });
          var _DraggableEvent = __webpack_require__(13);
          Object.keys(_DraggableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DraggableEvent[key];
              }
            });
          });
          var _Plugins = __webpack_require__(12);
          Object.keys(_Plugins).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _Plugins[key];
              }
            });
          });
          var _Sensors = __webpack_require__(6);
          Object.keys(_Sensors).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _Sensors[key];
              }
            });
          });
          var _Draggable = __webpack_require__(37);
          var _Draggable2 = _interopRequireDefault(_Draggable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Draggable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Sensor = __webpack_require__(4);
          Object.defineProperty(exports2, "Sensor", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Sensor).default;
            }
          });
          var _MouseSensor = __webpack_require__(46);
          Object.defineProperty(exports2, "MouseSensor", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_MouseSensor).default;
            }
          });
          var _TouchSensor = __webpack_require__(43);
          Object.defineProperty(exports2, "TouchSensor", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_TouchSensor).default;
            }
          });
          var _DragSensor = __webpack_require__(41);
          Object.defineProperty(exports2, "DragSensor", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_DragSensor).default;
            }
          });
          var _ForceTouchSensor = __webpack_require__(39);
          Object.defineProperty(exports2, "ForceTouchSensor", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_ForceTouchSensor).default;
            }
          });
          var _SensorEvent = __webpack_require__(3);
          Object.keys(_SensorEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SensorEvent[key];
              }
            });
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SnappableEvent = __webpack_require__(18);
          Object.keys(_SnappableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SnappableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _CollidableEvent = __webpack_require__(23);
          Object.keys(_CollidableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _CollidableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SortableEvent = __webpack_require__(27);
          Object.keys(_SortableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SortableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SwappableEvent = __webpack_require__(30);
          Object.keys(_SwappableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SwappableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DroppableEvent = __webpack_require__(33);
          Object.keys(_DroppableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DroppableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Announcement = __webpack_require__(62);
          Object.defineProperty(exports2, "Announcement", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Announcement).default;
            }
          });
          Object.defineProperty(exports2, "defaultAnnouncementOptions", {
            enumerable: true,
            get: function() {
              return _Announcement.defaultOptions;
            }
          });
          var _Focusable = __webpack_require__(59);
          Object.defineProperty(exports2, "Focusable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Focusable).default;
            }
          });
          var _Mirror = __webpack_require__(57);
          Object.defineProperty(exports2, "Mirror", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Mirror).default;
            }
          });
          Object.defineProperty(exports2, "defaultMirrorOptions", {
            enumerable: true,
            get: function() {
              return _Mirror.defaultOptions;
            }
          });
          var _Scrollable = __webpack_require__(53);
          Object.defineProperty(exports2, "Scrollable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Scrollable).default;
            }
          });
          Object.defineProperty(exports2, "defaultScrollableOptions", {
            enumerable: true,
            get: function() {
              return _Scrollable.defaultOptions;
            }
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DraggableEvent = __webpack_require__(63);
          Object.keys(_DraggableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DraggableEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DragEvent = __webpack_require__(65);
          Object.keys(_DragEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DragEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onSortableSorted = Symbol("onSortableSorted");
          const defaultOptions = exports2.defaultOptions = {
            duration: 150,
            easingFunction: "ease-in-out",
            horizontal: false
          };
          class SwapAnimation extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this.lastAnimationFrame = null;
              this[onSortableSorted] = this[onSortableSorted].bind(this);
            }
            attach() {
              this.draggable.on("sortable:sorted", this[onSortableSorted]);
            }
            detach() {
              this.draggable.off("sortable:sorted", this[onSortableSorted]);
            }
            getOptions() {
              return this.draggable.options.swapAnimation || {};
            }
            [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {
              const { source, over } = dragEvent;
              cancelAnimationFrame(this.lastAnimationFrame);
              this.lastAnimationFrame = requestAnimationFrame(() => {
                if (oldIndex >= newIndex) {
                  animate(source, over, this.options);
                } else {
                  animate(over, source, this.options);
                }
              });
            }
          }
          exports2.default = SwapAnimation;
          function animate(from, to, { duration, easingFunction, horizontal }) {
            for (const element of [from, to]) {
              element.style.pointerEvents = "none";
            }
            if (horizontal) {
              const width = from.offsetWidth;
              from.style.transform = `translate3d(${width}px, 0, 0)`;
              to.style.transform = `translate3d(-${width}px, 0, 0)`;
            } else {
              const height = from.offsetHeight;
              from.style.transform = `translate3d(0, ${height}px, 0)`;
              to.style.transform = `translate3d(0, -${height}px, 0)`;
            }
            requestAnimationFrame(() => {
              for (const element of [from, to]) {
                element.addEventListener("transitionend", resetElementOnTransitionEnd);
                element.style.transition = `transform ${duration}ms ${easingFunction}`;
                element.style.transform = "";
              }
            });
          }
          function resetElementOnTransitionEnd(event) {
            event.target.style.transition = "";
            event.target.style.pointerEvents = "";
            event.target.removeEventListener("transitionend", resetElementOnTransitionEnd);
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _SwapAnimation = __webpack_require__(15);
          var _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _SwapAnimation2.default;
          exports2.defaultOptions = _SwapAnimation.defaultOptions;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _SnappableEvent = __webpack_require__(7);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = Symbol("onDragStart");
          const onDragStop = Symbol("onDragStop");
          const onDragOver = Symbol("onDragOver");
          const onDragOut = Symbol("onDragOut");
          const onMirrorCreated = Symbol("onMirrorCreated");
          const onMirrorDestroy = Symbol("onMirrorDestroy");
          class Snappable extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.firstSource = null;
              this.mirror = null;
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this[onDragOver] = this[onDragOver].bind(this);
              this[onDragOut] = this[onDragOut].bind(this);
              this[onMirrorCreated] = this[onMirrorCreated].bind(this);
              this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
            }
            attach() {
              this.draggable.on("drag:start", this[onDragStart]).on("drag:stop", this[onDragStop]).on("drag:over", this[onDragOver]).on("drag:out", this[onDragOut]).on("droppable:over", this[onDragOver]).on("droppable:out", this[onDragOut]).on("mirror:created", this[onMirrorCreated]).on("mirror:destroy", this[onMirrorDestroy]);
            }
            detach() {
              this.draggable.off("drag:start", this[onDragStart]).off("drag:stop", this[onDragStop]).off("drag:over", this[onDragOver]).off("drag:out", this[onDragOut]).off("droppable:over", this[onDragOver]).off("droppable:out", this[onDragOut]).off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]);
            }
            [onDragStart](event) {
              if (event.canceled()) {
                return;
              }
              this.firstSource = event.source;
            }
            [onDragStop]() {
              this.firstSource = null;
            }
            [onDragOver](event) {
              if (event.canceled()) {
                return;
              }
              const source = event.source || event.dragEvent.source;
              if (source === this.firstSource) {
                this.firstSource = null;
                return;
              }
              const snapInEvent = new _SnappableEvent.SnapInEvent({
                dragEvent: event,
                snappable: event.over || event.droppable
              });
              this.draggable.trigger(snapInEvent);
              if (snapInEvent.canceled()) {
                return;
              }
              if (this.mirror) {
                this.mirror.style.display = "none";
              }
              source.classList.remove(this.draggable.getClassNameFor("source:dragging"));
              source.classList.add(this.draggable.getClassNameFor("source:placed"));
              setTimeout(() => {
                source.classList.remove(this.draggable.getClassNameFor("source:placed"));
              }, this.draggable.options.placedTimeout);
            }
            [onDragOut](event) {
              if (event.canceled()) {
                return;
              }
              const source = event.source || event.dragEvent.source;
              const snapOutEvent = new _SnappableEvent.SnapOutEvent({
                dragEvent: event,
                snappable: event.over || event.droppable
              });
              this.draggable.trigger(snapOutEvent);
              if (snapOutEvent.canceled()) {
                return;
              }
              if (this.mirror) {
                this.mirror.style.display = "";
              }
              source.classList.add(this.draggable.getClassNameFor("source:dragging"));
            }
            [onMirrorCreated]({ mirror }) {
              this.mirror = mirror;
            }
            [onMirrorDestroy]() {
              this.mirror = null;
            }
          }
          exports2.default = Snappable;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.SnapOutEvent = exports2.SnapInEvent = exports2.SnapEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class SnapEvent extends _AbstractEvent2.default {
            get dragEvent() {
              return this.data.dragEvent;
            }
            get snappable() {
              return this.data.snappable;
            }
          }
          exports2.SnapEvent = SnapEvent;
          SnapEvent.type = "snap";
          class SnapInEvent extends SnapEvent {
          }
          exports2.SnapInEvent = SnapInEvent;
          SnapInEvent.type = "snap:in";
          SnapInEvent.cancelable = true;
          class SnapOutEvent extends SnapEvent {
          }
          exports2.SnapOutEvent = SnapOutEvent;
          SnapOutEvent.type = "snap:out";
          SnapOutEvent.cancelable = true;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SnappableEvent = __webpack_require__(7);
          Object.keys(_SnappableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SnappableEvent[key];
              }
            });
          });
          var _Snappable = __webpack_require__(17);
          var _Snappable2 = _interopRequireDefault(_Snappable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Snappable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _utils = __webpack_require__(2);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onMirrorCreated = Symbol("onMirrorCreated");
          const onMirrorDestroy = Symbol("onMirrorDestroy");
          const onDragOver = Symbol("onDragOver");
          const resize = Symbol("resize");
          const defaultOptions = exports2.defaultOptions = {};
          class ResizeMirror extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this.lastWidth = 0;
              this.lastHeight = 0;
              this.mirror = null;
              this[onMirrorCreated] = this[onMirrorCreated].bind(this);
              this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
              this[onDragOver] = this[onDragOver].bind(this);
            }
            attach() {
              this.draggable.on("mirror:created", this[onMirrorCreated]).on("drag:over", this[onDragOver]).on("drag:over:container", this[onDragOver]);
            }
            detach() {
              this.draggable.off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]).off("drag:over", this[onDragOver]).off("drag:over:container", this[onDragOver]);
            }
            getOptions() {
              return this.draggable.options.resizeMirror || {};
            }
            [onMirrorCreated]({ mirror }) {
              this.mirror = mirror;
            }
            [onMirrorDestroy]() {
              this.mirror = null;
            }
            [onDragOver](dragEvent) {
              this[resize](dragEvent);
            }
            [resize]({ overContainer, over }) {
              requestAnimationFrame(() => {
                if (this.mirror.parentNode !== overContainer) {
                  overContainer.appendChild(this.mirror);
                }
                const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];
                if (!overElement) {
                  return;
                }
                (0, _utils.requestNextAnimationFrame)(() => {
                  const overRect = overElement.getBoundingClientRect();
                  if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {
                    return;
                  }
                  this.mirror.style.width = `${overRect.width}px`;
                  this.mirror.style.height = `${overRect.height}px`;
                  this.lastWidth = overRect.width;
                  this.lastHeight = overRect.height;
                });
              });
            }
          }
          exports2.default = ResizeMirror;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _ResizeMirror = __webpack_require__(20);
          var _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _ResizeMirror2.default;
          exports2.defaultOptions = _ResizeMirror.defaultOptions;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _utils = __webpack_require__(2);
          var _CollidableEvent = __webpack_require__(8);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragMove = Symbol("onDragMove");
          const onDragStop = Symbol("onDragStop");
          const onRequestAnimationFrame = Symbol("onRequestAnimationFrame");
          class Collidable extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.currentlyCollidingElement = null;
              this.lastCollidingElement = null;
              this.currentAnimationFrame = null;
              this[onDragMove] = this[onDragMove].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);
            }
            attach() {
              this.draggable.on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
            }
            detach() {
              this.draggable.off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
            }
            getCollidables() {
              const collidables = this.draggable.options.collidables;
              if (typeof collidables === "string") {
                return Array.prototype.slice.call(document.querySelectorAll(collidables));
              } else if (collidables instanceof NodeList || collidables instanceof Array) {
                return Array.prototype.slice.call(collidables);
              } else if (collidables instanceof HTMLElement) {
                return [collidables];
              } else if (typeof collidables === "function") {
                return collidables();
              } else {
                return [];
              }
            }
            [onDragMove](event) {
              const target = event.sensorEvent.target;
              this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));
              if (this.currentlyCollidingElement) {
                event.cancel();
              }
              const collidableInEvent = new _CollidableEvent.CollidableInEvent({
                dragEvent: event,
                collidingElement: this.currentlyCollidingElement
              });
              const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
                dragEvent: event,
                collidingElement: this.lastCollidingElement
              });
              const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
              const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);
              if (enteringCollidable) {
                if (this.lastCollidingElement) {
                  this.draggable.trigger(collidableOutEvent);
                }
                this.draggable.trigger(collidableInEvent);
              } else if (leavingCollidable) {
                this.draggable.trigger(collidableOutEvent);
              }
              this.lastCollidingElement = this.currentlyCollidingElement;
            }
            [onDragStop](event) {
              const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
              const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
                dragEvent: event,
                collidingElement: lastCollidingElement
              });
              if (lastCollidingElement) {
                this.draggable.trigger(collidableOutEvent);
              }
              this.lastCollidingElement = null;
              this.currentlyCollidingElement = null;
            }
            [onRequestAnimationFrame](target) {
              return () => {
                const collidables = this.getCollidables();
                this.currentlyCollidingElement = (0, _utils.closest)(target, (element) => collidables.includes(element));
              };
            }
          }
          exports2.default = Collidable;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.CollidableOutEvent = exports2.CollidableInEvent = exports2.CollidableEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class CollidableEvent extends _AbstractEvent2.default {
            get dragEvent() {
              return this.data.dragEvent;
            }
          }
          exports2.CollidableEvent = CollidableEvent;
          CollidableEvent.type = "collidable";
          class CollidableInEvent extends CollidableEvent {
            get collidingElement() {
              return this.data.collidingElement;
            }
          }
          exports2.CollidableInEvent = CollidableInEvent;
          CollidableInEvent.type = "collidable:in";
          class CollidableOutEvent extends CollidableEvent {
            get collidingElement() {
              return this.data.collidingElement;
            }
          }
          exports2.CollidableOutEvent = CollidableOutEvent;
          CollidableOutEvent.type = "collidable:out";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _CollidableEvent = __webpack_require__(8);
          Object.keys(_CollidableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _CollidableEvent[key];
              }
            });
          });
          var _Collidable = __webpack_require__(22);
          var _Collidable2 = _interopRequireDefault(_Collidable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Collidable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Collidable = __webpack_require__(24);
          Object.defineProperty(exports2, "Collidable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Collidable).default;
            }
          });
          var _ResizeMirror = __webpack_require__(21);
          Object.defineProperty(exports2, "ResizeMirror", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_ResizeMirror).default;
            }
          });
          Object.defineProperty(exports2, "defaultResizeMirrorOptions", {
            enumerable: true,
            get: function() {
              return _ResizeMirror.defaultOptions;
            }
          });
          var _Snappable = __webpack_require__(19);
          Object.defineProperty(exports2, "Snappable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Snappable).default;
            }
          });
          var _SwapAnimation = __webpack_require__(16);
          Object.defineProperty(exports2, "SwapAnimation", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_SwapAnimation).default;
            }
          });
          Object.defineProperty(exports2, "defaultSwapAnimationOptions", {
            enumerable: true,
            get: function() {
              return _SwapAnimation.defaultOptions;
            }
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _Draggable = __webpack_require__(5);
          var _Draggable2 = _interopRequireDefault(_Draggable);
          var _SortableEvent = __webpack_require__(9);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = Symbol("onDragStart");
          const onDragOverContainer = Symbol("onDragOverContainer");
          const onDragOver = Symbol("onDragOver");
          const onDragStop = Symbol("onDragStop");
          function onSortableSortedDefaultAnnouncement({ dragEvent }) {
            const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "sortable element";
            if (dragEvent.over) {
              const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || "sortable element";
              const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;
              if (isFollowing) {
                return `Placed ${sourceText} after ${overText}`;
              } else {
                return `Placed ${sourceText} before ${overText}`;
              }
            } else {
              return `Placed ${sourceText} into a different container`;
            }
          }
          const defaultAnnouncements = {
            "sortable:sorted": onSortableSortedDefaultAnnouncement
          };
          class Sortable extends _Draggable2.default {
            constructor(containers = [], options = {}) {
              super(containers, _extends({}, options, {
                announcements: _extends({}, defaultAnnouncements, options.announcements || {})
              }));
              this.startIndex = null;
              this.startContainer = null;
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragOverContainer] = this[onDragOverContainer].bind(this);
              this[onDragOver] = this[onDragOver].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this.on("drag:start", this[onDragStart]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver]).on("drag:stop", this[onDragStop]);
            }
            destroy() {
              super.destroy();
              this.off("drag:start", this[onDragStart]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver]).off("drag:stop", this[onDragStop]);
            }
            index(element) {
              return this.getDraggableElementsForContainer(element.parentNode).indexOf(element);
            }
            [onDragStart](event) {
              this.startContainer = event.source.parentNode;
              this.startIndex = this.index(event.source);
              const sortableStartEvent = new _SortableEvent.SortableStartEvent({
                dragEvent: event,
                startIndex: this.startIndex,
                startContainer: this.startContainer
              });
              this.trigger(sortableStartEvent);
              if (sortableStartEvent.canceled()) {
                event.cancel();
              }
            }
            [onDragOverContainer](event) {
              if (event.canceled()) {
                return;
              }
              const { source, over, overContainer } = event;
              const oldIndex = this.index(source);
              const sortableSortEvent = new _SortableEvent.SortableSortEvent({
                dragEvent: event,
                currentIndex: oldIndex,
                source,
                over
              });
              this.trigger(sortableSortEvent);
              if (sortableSortEvent.canceled()) {
                return;
              }
              const children = this.getDraggableElementsForContainer(overContainer);
              const moves = move({ source, over, overContainer, children });
              if (!moves) {
                return;
              }
              const { oldContainer, newContainer } = moves;
              const newIndex = this.index(event.source);
              const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
                dragEvent: event,
                oldIndex,
                newIndex,
                oldContainer,
                newContainer
              });
              this.trigger(sortableSortedEvent);
            }
            [onDragOver](event) {
              if (event.over === event.originalSource || event.over === event.source) {
                return;
              }
              const { source, over, overContainer } = event;
              const oldIndex = this.index(source);
              const sortableSortEvent = new _SortableEvent.SortableSortEvent({
                dragEvent: event,
                currentIndex: oldIndex,
                source,
                over
              });
              this.trigger(sortableSortEvent);
              if (sortableSortEvent.canceled()) {
                return;
              }
              const children = this.getDraggableElementsForContainer(overContainer);
              const moves = move({ source, over, overContainer, children });
              if (!moves) {
                return;
              }
              const { oldContainer, newContainer } = moves;
              const newIndex = this.index(source);
              const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
                dragEvent: event,
                oldIndex,
                newIndex,
                oldContainer,
                newContainer
              });
              this.trigger(sortableSortedEvent);
            }
            [onDragStop](event) {
              const sortableStopEvent = new _SortableEvent.SortableStopEvent({
                dragEvent: event,
                oldIndex: this.startIndex,
                newIndex: this.index(event.source),
                oldContainer: this.startContainer,
                newContainer: event.source.parentNode
              });
              this.trigger(sortableStopEvent);
              this.startIndex = null;
              this.startContainer = null;
            }
          }
          exports2.default = Sortable;
          function index(element) {
            return Array.prototype.indexOf.call(element.parentNode.children, element);
          }
          function move({ source, over, overContainer, children }) {
            const emptyOverContainer = !children.length;
            const differentContainer = source.parentNode !== overContainer;
            const sameContainer = over && !differentContainer;
            if (emptyOverContainer) {
              return moveInsideEmptyContainer(source, overContainer);
            } else if (sameContainer) {
              return moveWithinContainer(source, over);
            } else if (differentContainer) {
              return moveOutsideContainer(source, over, overContainer);
            } else {
              return null;
            }
          }
          function moveInsideEmptyContainer(source, overContainer) {
            const oldContainer = source.parentNode;
            overContainer.appendChild(source);
            return { oldContainer, newContainer: overContainer };
          }
          function moveWithinContainer(source, over) {
            const oldIndex = index(source);
            const newIndex = index(over);
            if (oldIndex < newIndex) {
              source.parentNode.insertBefore(source, over.nextElementSibling);
            } else {
              source.parentNode.insertBefore(source, over);
            }
            return { oldContainer: source.parentNode, newContainer: source.parentNode };
          }
          function moveOutsideContainer(source, over, overContainer) {
            const oldContainer = source.parentNode;
            if (over) {
              over.parentNode.insertBefore(source, over);
            } else {
              overContainer.appendChild(source);
            }
            return { oldContainer, newContainer: source.parentNode };
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.SortableStopEvent = exports2.SortableSortedEvent = exports2.SortableSortEvent = exports2.SortableStartEvent = exports2.SortableEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class SortableEvent extends _AbstractEvent2.default {
            get dragEvent() {
              return this.data.dragEvent;
            }
          }
          exports2.SortableEvent = SortableEvent;
          SortableEvent.type = "sortable";
          class SortableStartEvent extends SortableEvent {
            get startIndex() {
              return this.data.startIndex;
            }
            get startContainer() {
              return this.data.startContainer;
            }
          }
          exports2.SortableStartEvent = SortableStartEvent;
          SortableStartEvent.type = "sortable:start";
          SortableStartEvent.cancelable = true;
          class SortableSortEvent extends SortableEvent {
            get currentIndex() {
              return this.data.currentIndex;
            }
            get over() {
              return this.data.oldIndex;
            }
            get overContainer() {
              return this.data.newIndex;
            }
          }
          exports2.SortableSortEvent = SortableSortEvent;
          SortableSortEvent.type = "sortable:sort";
          SortableSortEvent.cancelable = true;
          class SortableSortedEvent extends SortableEvent {
            get oldIndex() {
              return this.data.oldIndex;
            }
            get newIndex() {
              return this.data.newIndex;
            }
            get oldContainer() {
              return this.data.oldContainer;
            }
            get newContainer() {
              return this.data.newContainer;
            }
          }
          exports2.SortableSortedEvent = SortableSortedEvent;
          SortableSortedEvent.type = "sortable:sorted";
          class SortableStopEvent extends SortableEvent {
            get oldIndex() {
              return this.data.oldIndex;
            }
            get newIndex() {
              return this.data.newIndex;
            }
            get oldContainer() {
              return this.data.oldContainer;
            }
            get newContainer() {
              return this.data.newContainer;
            }
          }
          exports2.SortableStopEvent = SortableStopEvent;
          SortableStopEvent.type = "sortable:stop";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SortableEvent = __webpack_require__(9);
          Object.keys(_SortableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SortableEvent[key];
              }
            });
          });
          var _Sortable = __webpack_require__(26);
          var _Sortable2 = _interopRequireDefault(_Sortable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Sortable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _Draggable = __webpack_require__(5);
          var _Draggable2 = _interopRequireDefault(_Draggable);
          var _SwappableEvent = __webpack_require__(10);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = Symbol("onDragStart");
          const onDragOver = Symbol("onDragOver");
          const onDragStop = Symbol("onDragStop");
          function onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {
            const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "swappable element";
            const overText = swappedElement.textContent.trim() || swappedElement.id || "swappable element";
            return `Swapped ${sourceText} with ${overText}`;
          }
          const defaultAnnouncements = {
            "swappabled:swapped": onSwappableSwappedDefaultAnnouncement
          };
          class Swappable extends _Draggable2.default {
            constructor(containers = [], options = {}) {
              super(containers, _extends({}, options, {
                announcements: _extends({}, defaultAnnouncements, options.announcements || {})
              }));
              this.lastOver = null;
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragOver] = this[onDragOver].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this.on("drag:start", this[onDragStart]).on("drag:over", this[onDragOver]).on("drag:stop", this[onDragStop]);
            }
            destroy() {
              super.destroy();
              this.off("drag:start", this._onDragStart).off("drag:over", this._onDragOver).off("drag:stop", this._onDragStop);
            }
            [onDragStart](event) {
              const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({
                dragEvent: event
              });
              this.trigger(swappableStartEvent);
              if (swappableStartEvent.canceled()) {
                event.cancel();
              }
            }
            [onDragOver](event) {
              if (event.over === event.originalSource || event.over === event.source || event.canceled()) {
                return;
              }
              const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({
                dragEvent: event,
                over: event.over,
                overContainer: event.overContainer
              });
              this.trigger(swappableSwapEvent);
              if (swappableSwapEvent.canceled()) {
                return;
              }
              if (this.lastOver && this.lastOver !== event.over) {
                swap(this.lastOver, event.source);
              }
              if (this.lastOver === event.over) {
                this.lastOver = null;
              } else {
                this.lastOver = event.over;
              }
              swap(event.source, event.over);
              const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({
                dragEvent: event,
                swappedElement: event.over
              });
              this.trigger(swappableSwappedEvent);
            }
            [onDragStop](event) {
              const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({
                dragEvent: event
              });
              this.trigger(swappableStopEvent);
              this.lastOver = null;
            }
          }
          exports2.default = Swappable;
          function withTempElement(callback) {
            const tmpElement = document.createElement("div");
            callback(tmpElement);
            tmpElement.parentNode.removeChild(tmpElement);
          }
          function swap(source, over) {
            const overParent = over.parentNode;
            const sourceParent = source.parentNode;
            withTempElement((tmpElement) => {
              sourceParent.insertBefore(tmpElement, source);
              overParent.insertBefore(source, over);
              sourceParent.insertBefore(over, tmpElement);
            });
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.SwappableStopEvent = exports2.SwappableSwappedEvent = exports2.SwappableSwapEvent = exports2.SwappableStartEvent = exports2.SwappableEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class SwappableEvent extends _AbstractEvent2.default {
            get dragEvent() {
              return this.data.dragEvent;
            }
          }
          exports2.SwappableEvent = SwappableEvent;
          SwappableEvent.type = "swappable";
          class SwappableStartEvent extends SwappableEvent {
          }
          exports2.SwappableStartEvent = SwappableStartEvent;
          SwappableStartEvent.type = "swappable:start";
          SwappableStartEvent.cancelable = true;
          class SwappableSwapEvent extends SwappableEvent {
            get over() {
              return this.data.over;
            }
            get overContainer() {
              return this.data.overContainer;
            }
          }
          exports2.SwappableSwapEvent = SwappableSwapEvent;
          SwappableSwapEvent.type = "swappable:swap";
          SwappableSwapEvent.cancelable = true;
          class SwappableSwappedEvent extends SwappableEvent {
            get swappedElement() {
              return this.data.swappedElement;
            }
          }
          exports2.SwappableSwappedEvent = SwappableSwappedEvent;
          SwappableSwappedEvent.type = "swappable:swapped";
          class SwappableStopEvent extends SwappableEvent {
          }
          exports2.SwappableStopEvent = SwappableStopEvent;
          SwappableStopEvent.type = "swappable:stop";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _SwappableEvent = __webpack_require__(10);
          Object.keys(_SwappableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _SwappableEvent[key];
              }
            });
          });
          var _Swappable = __webpack_require__(29);
          var _Swappable2 = _interopRequireDefault(_Swappable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Swappable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _utils = __webpack_require__(2);
          var _Draggable = __webpack_require__(5);
          var _Draggable2 = _interopRequireDefault(_Draggable);
          var _DroppableEvent = __webpack_require__(11);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = Symbol("onDragStart");
          const onDragMove = Symbol("onDragMove");
          const onDragStop = Symbol("onDragStop");
          const dropInDropzone = Symbol("dropInDropZone");
          const returnToOriginalDropzone = Symbol("returnToOriginalDropzone");
          const closestDropzone = Symbol("closestDropzone");
          const getDropzones = Symbol("getDropzones");
          function onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {
            const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "draggable element";
            const dropzoneText = dropzone.textContent.trim() || dropzone.id || "droppable element";
            return `Dropped ${sourceText} into ${dropzoneText}`;
          }
          function onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {
            const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "draggable element";
            const dropzoneText = dropzone.textContent.trim() || dropzone.id || "droppable element";
            return `Returned ${sourceText} from ${dropzoneText}`;
          }
          const defaultAnnouncements = {
            "droppable:dropped": onDroppableDroppedDefaultAnnouncement,
            "droppable:returned": onDroppableReturnedDefaultAnnouncement
          };
          const defaultClasses = {
            "droppable:active": "draggable-dropzone--active",
            "droppable:occupied": "draggable-dropzone--occupied"
          };
          const defaultOptions = {
            dropzone: ".draggable-droppable"
          };
          class Droppable extends _Draggable2.default {
            constructor(containers = [], options = {}) {
              super(containers, _extends({}, defaultOptions, options, {
                classes: _extends({}, defaultClasses, options.classes || {}),
                announcements: _extends({}, defaultAnnouncements, options.announcements || {})
              }));
              this.dropzones = null;
              this.lastDropzone = null;
              this.initialDropzone = null;
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragMove] = this[onDragMove].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
            }
            destroy() {
              super.destroy();
              this.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
            }
            [onDragStart](event) {
              if (event.canceled()) {
                return;
              }
              this.dropzones = [...this[getDropzones]()];
              const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);
              if (!dropzone) {
                event.cancel();
                return;
              }
              const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({
                dragEvent: event,
                dropzone
              });
              this.trigger(droppableStartEvent);
              if (droppableStartEvent.canceled()) {
                event.cancel();
                return;
              }
              this.initialDropzone = dropzone;
              for (const dropzoneElement of this.dropzones) {
                if (dropzoneElement.classList.contains(this.getClassNameFor("droppable:occupied"))) {
                  continue;
                }
                dropzoneElement.classList.add(this.getClassNameFor("droppable:active"));
              }
            }
            [onDragMove](event) {
              if (event.canceled()) {
                return;
              }
              const dropzone = this[closestDropzone](event.sensorEvent.target);
              const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor("droppable:occupied"));
              if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {
                this.lastDropzone = dropzone;
              } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {
                this[returnToOriginalDropzone](event);
                this.lastDropzone = null;
              }
            }
            [onDragStop](event) {
              const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({
                dragEvent: event,
                dropzone: this.lastDropzone || this.initialDropzone
              });
              this.trigger(droppableStopEvent);
              const occupiedClass = this.getClassNameFor("droppable:occupied");
              for (const dropzone of this.dropzones) {
                dropzone.classList.remove(this.getClassNameFor("droppable:active"));
              }
              if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {
                this.initialDropzone.classList.remove(occupiedClass);
              }
              this.dropzones = null;
              this.lastDropzone = null;
              this.initialDropzone = null;
            }
            [dropInDropzone](event, dropzone) {
              const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({
                dragEvent: event,
                dropzone
              });
              this.trigger(droppableDroppedEvent);
              if (droppableDroppedEvent.canceled()) {
                return false;
              }
              const occupiedClass = this.getClassNameFor("droppable:occupied");
              if (this.lastDropzone) {
                this.lastDropzone.classList.remove(occupiedClass);
              }
              dropzone.appendChild(event.source);
              dropzone.classList.add(occupiedClass);
              return true;
            }
            [returnToOriginalDropzone](event) {
              const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({
                dragEvent: event,
                dropzone: this.lastDropzone
              });
              this.trigger(droppableReturnedEvent);
              if (droppableReturnedEvent.canceled()) {
                return;
              }
              this.initialDropzone.appendChild(event.source);
              this.lastDropzone.classList.remove(this.getClassNameFor("droppable:occupied"));
            }
            [closestDropzone](target) {
              if (!this.dropzones) {
                return null;
              }
              return (0, _utils.closest)(target, this.dropzones);
            }
            [getDropzones]() {
              const dropzone = this.options.dropzone;
              if (typeof dropzone === "string") {
                return document.querySelectorAll(dropzone);
              } else if (dropzone instanceof NodeList || dropzone instanceof Array) {
                return dropzone;
              } else if (typeof dropzone === "function") {
                return dropzone();
              } else {
                return [];
              }
            }
          }
          exports2.default = Droppable;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DroppableStopEvent = exports2.DroppableReturnedEvent = exports2.DroppableDroppedEvent = exports2.DroppableStartEvent = exports2.DroppableEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class DroppableEvent extends _AbstractEvent2.default {
            get dragEvent() {
              return this.data.dragEvent;
            }
          }
          exports2.DroppableEvent = DroppableEvent;
          DroppableEvent.type = "droppable";
          class DroppableStartEvent extends DroppableEvent {
            get dropzone() {
              return this.data.dropzone;
            }
          }
          exports2.DroppableStartEvent = DroppableStartEvent;
          DroppableStartEvent.type = "droppable:start";
          DroppableStartEvent.cancelable = true;
          class DroppableDroppedEvent extends DroppableEvent {
            get dropzone() {
              return this.data.dropzone;
            }
          }
          exports2.DroppableDroppedEvent = DroppableDroppedEvent;
          DroppableDroppedEvent.type = "droppable:dropped";
          DroppableDroppedEvent.cancelable = true;
          class DroppableReturnedEvent extends DroppableEvent {
            get dropzone() {
              return this.data.dropzone;
            }
          }
          exports2.DroppableReturnedEvent = DroppableReturnedEvent;
          DroppableReturnedEvent.type = "droppable:returned";
          DroppableReturnedEvent.cancelable = true;
          class DroppableStopEvent extends DroppableEvent {
            get dropzone() {
              return this.data.dropzone;
            }
          }
          exports2.DroppableStopEvent = DroppableStopEvent;
          DroppableStopEvent.type = "droppable:stop";
          DroppableStopEvent.cancelable = true;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DroppableEvent = __webpack_require__(11);
          Object.keys(_DroppableEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _DroppableEvent[key];
              }
            });
          });
          var _Droppable = __webpack_require__(32);
          var _Droppable2 = _interopRequireDefault(_Droppable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Droppable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          class Emitter {
            constructor() {
              this.callbacks = {};
            }
            on(type, ...callbacks) {
              if (!this.callbacks[type]) {
                this.callbacks[type] = [];
              }
              this.callbacks[type].push(...callbacks);
              return this;
            }
            off(type, callback) {
              if (!this.callbacks[type]) {
                return null;
              }
              const copy = this.callbacks[type].slice(0);
              for (let i = 0; i < copy.length; i++) {
                if (callback === copy[i]) {
                  this.callbacks[type].splice(i, 1);
                }
              }
              return this;
            }
            trigger(event) {
              if (!this.callbacks[event.type]) {
                return null;
              }
              const callbacks = [...this.callbacks[event.type]];
              const caughtErrors = [];
              for (let i = callbacks.length - 1; i >= 0; i--) {
                const callback = callbacks[i];
                try {
                  callback(event);
                } catch (error) {
                  caughtErrors.push(error);
                }
              }
              if (caughtErrors.length) {
                console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);
              }
              return this;
            }
          }
          exports2.default = Emitter;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Emitter = __webpack_require__(35);
          var _Emitter2 = _interopRequireDefault(_Emitter);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Emitter2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _utils = __webpack_require__(2);
          var _Plugins = __webpack_require__(12);
          var _Emitter = __webpack_require__(36);
          var _Emitter2 = _interopRequireDefault(_Emitter);
          var _Sensors = __webpack_require__(6);
          var _DraggableEvent = __webpack_require__(13);
          var _DragEvent = __webpack_require__(14);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = Symbol("onDragStart");
          const onDragMove = Symbol("onDragMove");
          const onDragStop = Symbol("onDragStop");
          const onDragPressure = Symbol("onDragPressure");
          const defaultAnnouncements = {
            "drag:start": (event) => `Picked up ${event.source.textContent.trim() || event.source.id || "draggable element"}`,
            "drag:stop": (event) => `Released ${event.source.textContent.trim() || event.source.id || "draggable element"}`
          };
          const defaultClasses = {
            "container:dragging": "draggable-container--is-dragging",
            "source:dragging": "draggable-source--is-dragging",
            "source:placed": "draggable-source--placed",
            "container:placed": "draggable-container--placed",
            "body:dragging": "draggable--is-dragging",
            "draggable:over": "draggable--over",
            "container:over": "draggable-container--over",
            "source:original": "draggable--original",
            mirror: "draggable-mirror"
          };
          const defaultOptions = exports2.defaultOptions = {
            draggable: ".draggable-source",
            handle: null,
            delay: 100,
            placedTimeout: 800,
            plugins: [],
            sensors: []
          };
          class Draggable {
            constructor(containers = [document.body], options = {}) {
              if (containers instanceof NodeList || containers instanceof Array) {
                this.containers = [...containers];
              } else if (containers instanceof HTMLElement) {
                this.containers = [containers];
              } else {
                throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
              }
              this.options = _extends({}, defaultOptions, options, {
                classes: _extends({}, defaultClasses, options.classes || {}),
                announcements: _extends({}, defaultAnnouncements, options.announcements || {})
              });
              this.emitter = new _Emitter2.default();
              this.dragging = false;
              this.plugins = [];
              this.sensors = [];
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragMove] = this[onDragMove].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this[onDragPressure] = this[onDragPressure].bind(this);
              document.addEventListener("drag:start", this[onDragStart], true);
              document.addEventListener("drag:move", this[onDragMove], true);
              document.addEventListener("drag:stop", this[onDragStop], true);
              document.addEventListener("drag:pressure", this[onDragPressure], true);
              const defaultPlugins = Object.values(Draggable.Plugins).map((Plugin) => Plugin);
              const defaultSensors = [_Sensors.MouseSensor, _Sensors.TouchSensor];
              this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);
              this.addSensor(...[...defaultSensors, ...this.options.sensors]);
              const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({
                draggable: this
              });
              this.on("mirror:created", ({ mirror }) => this.mirror = mirror);
              this.on("mirror:destroy", () => this.mirror = null);
              this.trigger(draggableInitializedEvent);
            }
            destroy() {
              document.removeEventListener("drag:start", this[onDragStart], true);
              document.removeEventListener("drag:move", this[onDragMove], true);
              document.removeEventListener("drag:stop", this[onDragStop], true);
              document.removeEventListener("drag:pressure", this[onDragPressure], true);
              const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({
                draggable: this
              });
              this.trigger(draggableDestroyEvent);
              this.removePlugin(...this.plugins.map((plugin) => plugin.constructor));
              this.removeSensor(...this.sensors.map((sensor) => sensor.constructor));
            }
            addPlugin(...plugins) {
              const activePlugins = plugins.map((Plugin) => new Plugin(this));
              activePlugins.forEach((plugin) => plugin.attach());
              this.plugins = [...this.plugins, ...activePlugins];
              return this;
            }
            removePlugin(...plugins) {
              const removedPlugins = this.plugins.filter((plugin) => plugins.includes(plugin.constructor));
              removedPlugins.forEach((plugin) => plugin.detach());
              this.plugins = this.plugins.filter((plugin) => !plugins.includes(plugin.constructor));
              return this;
            }
            addSensor(...sensors) {
              const activeSensors = sensors.map((Sensor) => new Sensor(this.containers, this.options));
              activeSensors.forEach((sensor) => sensor.attach());
              this.sensors = [...this.sensors, ...activeSensors];
              return this;
            }
            removeSensor(...sensors) {
              const removedSensors = this.sensors.filter((sensor) => sensors.includes(sensor.constructor));
              removedSensors.forEach((sensor) => sensor.detach());
              this.sensors = this.sensors.filter((sensor) => !sensors.includes(sensor.constructor));
              return this;
            }
            addContainer(...containers) {
              this.containers = [...this.containers, ...containers];
              this.sensors.forEach((sensor) => sensor.addContainer(...containers));
              return this;
            }
            removeContainer(...containers) {
              this.containers = this.containers.filter((container) => !containers.includes(container));
              this.sensors.forEach((sensor) => sensor.removeContainer(...containers));
              return this;
            }
            on(type, ...callbacks) {
              this.emitter.on(type, ...callbacks);
              return this;
            }
            off(type, callback) {
              this.emitter.off(type, callback);
              return this;
            }
            trigger(event) {
              this.emitter.trigger(event);
              return this;
            }
            getClassNameFor(name) {
              return this.options.classes[name];
            }
            isDragging() {
              return Boolean(this.dragging);
            }
            getDraggableElements() {
              return this.containers.reduce((current, container) => {
                return [...current, ...this.getDraggableElementsForContainer(container)];
              }, []);
            }
            getDraggableElementsForContainer(container) {
              const allDraggableElements = container.querySelectorAll(this.options.draggable);
              return [...allDraggableElements].filter((childElement) => {
                return childElement !== this.originalSource && childElement !== this.mirror;
              });
            }
            [onDragStart](event) {
              const sensorEvent = getSensorEvent(event);
              const { target, container } = sensorEvent;
              if (!this.containers.includes(container)) {
                return;
              }
              if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {
                sensorEvent.cancel();
                return;
              }
              this.originalSource = (0, _utils.closest)(target, this.options.draggable);
              this.sourceContainer = container;
              if (!this.originalSource) {
                sensorEvent.cancel();
                return;
              }
              if (this.lastPlacedSource && this.lastPlacedContainer) {
                clearTimeout(this.placedTimeoutID);
                this.lastPlacedSource.classList.remove(this.getClassNameFor("source:placed"));
                this.lastPlacedContainer.classList.remove(this.getClassNameFor("container:placed"));
              }
              this.source = this.originalSource.cloneNode(true);
              this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
              this.originalSource.style.display = "none";
              const dragEvent = new _DragEvent.DragStartEvent({
                source: this.source,
                originalSource: this.originalSource,
                sourceContainer: container,
                sensorEvent
              });
              this.trigger(dragEvent);
              this.dragging = !dragEvent.canceled();
              if (dragEvent.canceled()) {
                this.source.parentNode.removeChild(this.source);
                this.originalSource.style.display = null;
                return;
              }
              this.originalSource.classList.add(this.getClassNameFor("source:original"));
              this.source.classList.add(this.getClassNameFor("source:dragging"));
              this.sourceContainer.classList.add(this.getClassNameFor("container:dragging"));
              document.body.classList.add(this.getClassNameFor("body:dragging"));
              applyUserSelect(document.body, "none");
              requestAnimationFrame(() => {
                const oldSensorEvent = getSensorEvent(event);
                const newSensorEvent = oldSensorEvent.clone({ target: this.source });
                this[onDragMove](_extends({}, event, {
                  detail: newSensorEvent
                }));
              });
            }
            [onDragMove](event) {
              if (!this.dragging) {
                return;
              }
              const sensorEvent = getSensorEvent(event);
              const { container } = sensorEvent;
              let target = sensorEvent.target;
              const dragMoveEvent = new _DragEvent.DragMoveEvent({
                source: this.source,
                originalSource: this.originalSource,
                sourceContainer: container,
                sensorEvent
              });
              this.trigger(dragMoveEvent);
              if (dragMoveEvent.canceled()) {
                sensorEvent.cancel();
              }
              target = (0, _utils.closest)(target, this.options.draggable);
              const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);
              const overContainer = sensorEvent.overContainer || withinCorrectContainer;
              const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
              const isLeavingDraggable = this.currentOver && target !== this.currentOver;
              const isOverContainer = overContainer && this.currentOverContainer !== overContainer;
              const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;
              if (isLeavingDraggable) {
                const dragOutEvent = new _DragEvent.DragOutEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent,
                  over: this.currentOver
                });
                this.currentOver.classList.remove(this.getClassNameFor("draggable:over"));
                this.currentOver = null;
                this.trigger(dragOutEvent);
              }
              if (isLeavingContainer) {
                const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent,
                  overContainer: this.currentOverContainer
                });
                this.currentOverContainer.classList.remove(this.getClassNameFor("container:over"));
                this.currentOverContainer = null;
                this.trigger(dragOutContainerEvent);
              }
              if (isOverContainer) {
                overContainer.classList.add(this.getClassNameFor("container:over"));
                const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent,
                  overContainer
                });
                this.currentOverContainer = overContainer;
                this.trigger(dragOverContainerEvent);
              }
              if (isOverDraggable) {
                target.classList.add(this.getClassNameFor("draggable:over"));
                const dragOverEvent = new _DragEvent.DragOverEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent,
                  overContainer,
                  over: target
                });
                this.currentOver = target;
                this.trigger(dragOverEvent);
              }
            }
            [onDragStop](event) {
              if (!this.dragging) {
                return;
              }
              this.dragging = false;
              const dragStopEvent = new _DragEvent.DragStopEvent({
                source: this.source,
                originalSource: this.originalSource,
                sensorEvent: event.sensorEvent,
                sourceContainer: this.sourceContainer
              });
              this.trigger(dragStopEvent);
              this.source.parentNode.insertBefore(this.originalSource, this.source);
              this.source.parentNode.removeChild(this.source);
              this.originalSource.style.display = "";
              this.source.classList.remove(this.getClassNameFor("source:dragging"));
              this.originalSource.classList.remove(this.getClassNameFor("source:original"));
              this.originalSource.classList.add(this.getClassNameFor("source:placed"));
              this.sourceContainer.classList.add(this.getClassNameFor("container:placed"));
              this.sourceContainer.classList.remove(this.getClassNameFor("container:dragging"));
              document.body.classList.remove(this.getClassNameFor("body:dragging"));
              applyUserSelect(document.body, "");
              if (this.currentOver) {
                this.currentOver.classList.remove(this.getClassNameFor("draggable:over"));
              }
              if (this.currentOverContainer) {
                this.currentOverContainer.classList.remove(this.getClassNameFor("container:over"));
              }
              this.lastPlacedSource = this.originalSource;
              this.lastPlacedContainer = this.sourceContainer;
              this.placedTimeoutID = setTimeout(() => {
                if (this.lastPlacedSource) {
                  this.lastPlacedSource.classList.remove(this.getClassNameFor("source:placed"));
                }
                if (this.lastPlacedContainer) {
                  this.lastPlacedContainer.classList.remove(this.getClassNameFor("container:placed"));
                }
                this.lastPlacedSource = null;
                this.lastPlacedContainer = null;
              }, this.options.placedTimeout);
              this.source = null;
              this.originalSource = null;
              this.currentOverContainer = null;
              this.currentOver = null;
              this.sourceContainer = null;
            }
            [onDragPressure](event) {
              if (!this.dragging) {
                return;
              }
              const sensorEvent = getSensorEvent(event);
              const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);
              const dragPressureEvent = new _DragEvent.DragPressureEvent({
                sensorEvent,
                source,
                pressure: sensorEvent.pressure
              });
              this.trigger(dragPressureEvent);
            }
          }
          exports2.default = Draggable;
          Draggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };
          function getSensorEvent(event) {
            return event.detail;
          }
          function applyUserSelect(element, value) {
            element.style.webkitUserSelect = value;
            element.style.mozUserSelect = value;
            element.style.msUserSelect = value;
            element.style.oUserSelect = value;
            element.style.userSelect = value;
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Sensor = __webpack_require__(4);
          var _Sensor2 = _interopRequireDefault(_Sensor);
          var _SensorEvent = __webpack_require__(3);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onMouseForceWillBegin = Symbol("onMouseForceWillBegin");
          const onMouseForceDown = Symbol("onMouseForceDown");
          const onMouseDown = Symbol("onMouseDown");
          const onMouseForceChange = Symbol("onMouseForceChange");
          const onMouseMove = Symbol("onMouseMove");
          const onMouseUp = Symbol("onMouseUp");
          const onMouseForceGlobalChange = Symbol("onMouseForceGlobalChange");
          class ForceTouchSensor extends _Sensor2.default {
            constructor(containers = [], options = {}) {
              super(containers, options);
              this.mightDrag = false;
              this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);
              this[onMouseForceDown] = this[onMouseForceDown].bind(this);
              this[onMouseDown] = this[onMouseDown].bind(this);
              this[onMouseForceChange] = this[onMouseForceChange].bind(this);
              this[onMouseMove] = this[onMouseMove].bind(this);
              this[onMouseUp] = this[onMouseUp].bind(this);
            }
            attach() {
              for (const container of this.containers) {
                container.addEventListener("webkitmouseforcewillbegin", this[onMouseForceWillBegin], false);
                container.addEventListener("webkitmouseforcedown", this[onMouseForceDown], false);
                container.addEventListener("mousedown", this[onMouseDown], true);
                container.addEventListener("webkitmouseforcechanged", this[onMouseForceChange], false);
              }
              document.addEventListener("mousemove", this[onMouseMove]);
              document.addEventListener("mouseup", this[onMouseUp]);
            }
            detach() {
              for (const container of this.containers) {
                container.removeEventListener("webkitmouseforcewillbegin", this[onMouseForceWillBegin], false);
                container.removeEventListener("webkitmouseforcedown", this[onMouseForceDown], false);
                container.removeEventListener("mousedown", this[onMouseDown], true);
                container.removeEventListener("webkitmouseforcechanged", this[onMouseForceChange], false);
              }
              document.removeEventListener("mousemove", this[onMouseMove]);
              document.removeEventListener("mouseup", this[onMouseUp]);
            }
            [onMouseForceWillBegin](event) {
              event.preventDefault();
              this.mightDrag = true;
            }
            [onMouseForceDown](event) {
              if (this.dragging) {
                return;
              }
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const container = event.currentTarget;
              const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container,
                originalEvent: event
              });
              this.trigger(container, dragStartEvent);
              this.currentContainer = container;
              this.dragging = !dragStartEvent.canceled();
              this.mightDrag = false;
            }
            [onMouseUp](event) {
              if (!this.dragging) {
                return;
              }
              const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target: null,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragStopEvent);
              this.currentContainer = null;
              this.dragging = false;
              this.mightDrag = false;
            }
            [onMouseDown](event) {
              if (!this.mightDrag) {
                return;
              }
              event.stopPropagation();
              event.stopImmediatePropagation();
              event.preventDefault();
            }
            [onMouseMove](event) {
              if (!this.dragging) {
                return;
              }
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragMoveEvent);
            }
            [onMouseForceChange](event) {
              if (this.dragging) {
                return;
              }
              const target = event.target;
              const container = event.currentTarget;
              const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
                pressure: event.webkitForce,
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container,
                originalEvent: event
              });
              this.trigger(container, dragPressureEvent);
            }
            [onMouseForceGlobalChange](event) {
              if (!this.dragging) {
                return;
              }
              const target = event.target;
              const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
                pressure: event.webkitForce,
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragPressureEvent);
            }
          }
          exports2.default = ForceTouchSensor;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _ForceTouchSensor = __webpack_require__(38);
          var _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _ForceTouchSensor2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _utils = __webpack_require__(2);
          var _Sensor = __webpack_require__(4);
          var _Sensor2 = _interopRequireDefault(_Sensor);
          var _SensorEvent = __webpack_require__(3);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onMouseDown = Symbol("onMouseDown");
          const onMouseUp = Symbol("onMouseUp");
          const onDragStart = Symbol("onDragStart");
          const onDragOver = Symbol("onDragOver");
          const onDragEnd = Symbol("onDragEnd");
          const onDrop = Symbol("onDrop");
          const reset = Symbol("reset");
          class DragSensor extends _Sensor2.default {
            constructor(containers = [], options = {}) {
              super(containers, options);
              this.mouseDownTimeout = null;
              this.draggableElement = null;
              this.nativeDraggableElement = null;
              this[onMouseDown] = this[onMouseDown].bind(this);
              this[onMouseUp] = this[onMouseUp].bind(this);
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragOver] = this[onDragOver].bind(this);
              this[onDragEnd] = this[onDragEnd].bind(this);
              this[onDrop] = this[onDrop].bind(this);
            }
            attach() {
              document.addEventListener("mousedown", this[onMouseDown], true);
            }
            detach() {
              document.removeEventListener("mousedown", this[onMouseDown], true);
            }
            [onDragStart](event) {
              event.dataTransfer.setData("text", "");
              event.dataTransfer.effectAllowed = this.options.type;
              const target = document.elementFromPoint(event.clientX, event.clientY);
              this.currentContainer = (0, _utils.closest)(event.target, this.containers);
              if (!this.currentContainer) {
                return;
              }
              const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              setTimeout(() => {
                this.trigger(this.currentContainer, dragStartEvent);
                if (dragStartEvent.canceled()) {
                  this.dragging = false;
                } else {
                  this.dragging = true;
                }
              }, 0);
            }
            [onDragOver](event) {
              if (!this.dragging) {
                return;
              }
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const container = this.currentContainer;
              const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container,
                originalEvent: event
              });
              this.trigger(container, dragMoveEvent);
              if (!dragMoveEvent.canceled()) {
                event.preventDefault();
                event.dataTransfer.dropEffect = this.options.type;
              }
            }
            [onDragEnd](event) {
              if (!this.dragging) {
                return;
              }
              document.removeEventListener("mouseup", this[onMouseUp], true);
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const container = this.currentContainer;
              const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container,
                originalEvent: event
              });
              this.trigger(container, dragStopEvent);
              this.dragging = false;
              this[reset]();
            }
            [onDrop](event) {
              event.preventDefault();
            }
            [onMouseDown](event) {
              if (event.target && (event.target.form || event.target.contenteditable)) {
                return;
              }
              const nativeDraggableElement = (0, _utils.closest)(event.target, (element) => element.draggable);
              if (nativeDraggableElement) {
                nativeDraggableElement.draggable = false;
                this.nativeDraggableElement = nativeDraggableElement;
              }
              document.addEventListener("mouseup", this[onMouseUp], true);
              document.addEventListener("dragstart", this[onDragStart], false);
              document.addEventListener("dragover", this[onDragOver], false);
              document.addEventListener("dragend", this[onDragEnd], false);
              document.addEventListener("drop", this[onDrop], false);
              const target = (0, _utils.closest)(event.target, this.options.draggable);
              if (!target) {
                return;
              }
              this.mouseDownTimeout = setTimeout(() => {
                target.draggable = true;
                this.draggableElement = target;
              }, this.options.delay);
            }
            [onMouseUp]() {
              this[reset]();
            }
            [reset]() {
              clearTimeout(this.mouseDownTimeout);
              document.removeEventListener("mouseup", this[onMouseUp], true);
              document.removeEventListener("dragstart", this[onDragStart], false);
              document.removeEventListener("dragover", this[onDragOver], false);
              document.removeEventListener("dragend", this[onDragEnd], false);
              document.removeEventListener("drop", this[onDrop], false);
              if (this.nativeDraggableElement) {
                this.nativeDraggableElement.draggable = true;
                this.nativeDraggableElement = null;
              }
              if (this.draggableElement) {
                this.draggableElement.draggable = false;
                this.draggableElement = null;
              }
            }
          }
          exports2.default = DragSensor;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _DragSensor = __webpack_require__(40);
          var _DragSensor2 = _interopRequireDefault(_DragSensor);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _DragSensor2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _utils = __webpack_require__(2);
          var _Sensor = __webpack_require__(4);
          var _Sensor2 = _interopRequireDefault(_Sensor);
          var _SensorEvent = __webpack_require__(3);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onTouchStart = Symbol("onTouchStart");
          const onTouchHold = Symbol("onTouchHold");
          const onTouchEnd = Symbol("onTouchEnd");
          const onTouchMove = Symbol("onTouchMove");
          let preventScrolling = false;
          window.addEventListener("touchmove", (event) => {
            if (!preventScrolling) {
              return;
            }
            event.preventDefault();
          }, { passive: false });
          class TouchSensor extends _Sensor2.default {
            constructor(containers = [], options = {}) {
              super(containers, options);
              this.currentScrollableParent = null;
              this.tapTimeout = null;
              this.touchMoved = false;
              this[onTouchStart] = this[onTouchStart].bind(this);
              this[onTouchHold] = this[onTouchHold].bind(this);
              this[onTouchEnd] = this[onTouchEnd].bind(this);
              this[onTouchMove] = this[onTouchMove].bind(this);
            }
            attach() {
              document.addEventListener("touchstart", this[onTouchStart]);
            }
            detach() {
              document.removeEventListener("touchstart", this[onTouchStart]);
            }
            [onTouchStart](event) {
              const container = (0, _utils.closest)(event.target, this.containers);
              if (!container) {
                return;
              }
              document.addEventListener("touchmove", this[onTouchMove]);
              document.addEventListener("touchend", this[onTouchEnd]);
              document.addEventListener("touchcancel", this[onTouchEnd]);
              container.addEventListener("contextmenu", onContextMenu);
              this.currentContainer = container;
              this.tapTimeout = setTimeout(this[onTouchHold](event, container), this.options.delay);
            }
            [onTouchHold](event, container) {
              return () => {
                if (this.touchMoved) {
                  return;
                }
                const touch = event.touches[0] || event.changedTouches[0];
                const target = event.target;
                const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                  clientX: touch.pageX,
                  clientY: touch.pageY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragStartEvent);
                this.dragging = !dragStartEvent.canceled();
                preventScrolling = this.dragging;
              };
            }
            [onTouchMove](event) {
              this.touchMoved = true;
              if (!this.dragging) {
                return;
              }
              const touch = event.touches[0] || event.changedTouches[0];
              const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
              const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                clientX: touch.pageX,
                clientY: touch.pageY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragMoveEvent);
            }
            [onTouchEnd](event) {
              this.touchMoved = false;
              preventScrolling = false;
              document.removeEventListener("touchend", this[onTouchEnd]);
              document.removeEventListener("touchcancel", this[onTouchEnd]);
              document.removeEventListener("touchmove", this[onTouchMove]);
              if (this.currentContainer) {
                this.currentContainer.removeEventListener("contextmenu", onContextMenu);
              }
              clearTimeout(this.tapTimeout);
              if (!this.dragging) {
                return;
              }
              const touch = event.touches[0] || event.changedTouches[0];
              const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
              event.preventDefault();
              const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                clientX: touch.pageX,
                clientY: touch.pageY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragStopEvent);
              this.currentContainer = null;
              this.dragging = false;
            }
          }
          exports2.default = TouchSensor;
          function onContextMenu(event) {
            event.preventDefault();
            event.stopPropagation();
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _TouchSensor = __webpack_require__(42);
          var _TouchSensor2 = _interopRequireDefault(_TouchSensor);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _TouchSensor2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DragPressureSensorEvent = exports2.DragStopSensorEvent = exports2.DragMoveSensorEvent = exports2.DragStartSensorEvent = exports2.SensorEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class SensorEvent extends _AbstractEvent2.default {
            get originalEvent() {
              return this.data.originalEvent;
            }
            get clientX() {
              return this.data.clientX;
            }
            get clientY() {
              return this.data.clientY;
            }
            get target() {
              return this.data.target;
            }
            get container() {
              return this.data.container;
            }
            get pressure() {
              return this.data.pressure;
            }
          }
          exports2.SensorEvent = SensorEvent;
          class DragStartSensorEvent extends SensorEvent {
          }
          exports2.DragStartSensorEvent = DragStartSensorEvent;
          DragStartSensorEvent.type = "drag:start";
          class DragMoveSensorEvent extends SensorEvent {
          }
          exports2.DragMoveSensorEvent = DragMoveSensorEvent;
          DragMoveSensorEvent.type = "drag:move";
          class DragStopSensorEvent extends SensorEvent {
          }
          exports2.DragStopSensorEvent = DragStopSensorEvent;
          DragStopSensorEvent.type = "drag:stop";
          class DragPressureSensorEvent extends SensorEvent {
          }
          exports2.DragPressureSensorEvent = DragPressureSensorEvent;
          DragPressureSensorEvent.type = "drag:pressure";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _utils = __webpack_require__(2);
          var _Sensor = __webpack_require__(4);
          var _Sensor2 = _interopRequireDefault(_Sensor);
          var _SensorEvent = __webpack_require__(3);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging");
          const onMouseDown = Symbol("onMouseDown");
          const onMouseMove = Symbol("onMouseMove");
          const onMouseUp = Symbol("onMouseUp");
          class MouseSensor extends _Sensor2.default {
            constructor(containers = [], options = {}) {
              super(containers, options);
              this.mouseDown = false;
              this.mouseDownTimeout = null;
              this.openedContextMenu = false;
              this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);
              this[onMouseDown] = this[onMouseDown].bind(this);
              this[onMouseMove] = this[onMouseMove].bind(this);
              this[onMouseUp] = this[onMouseUp].bind(this);
            }
            attach() {
              document.addEventListener("mousedown", this[onMouseDown], true);
            }
            detach() {
              document.removeEventListener("mousedown", this[onMouseDown], true);
            }
            [onMouseDown](event) {
              if (event.button !== 0 || event.ctrlKey || event.metaKey) {
                return;
              }
              document.addEventListener("mouseup", this[onMouseUp]);
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const container = (0, _utils.closest)(target, this.containers);
              if (!container) {
                return;
              }
              document.addEventListener("dragstart", preventNativeDragStart);
              this.mouseDown = true;
              clearTimeout(this.mouseDownTimeout);
              this.mouseDownTimeout = setTimeout(() => {
                if (!this.mouseDown) {
                  return;
                }
                const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragStartEvent);
                this.currentContainer = container;
                this.dragging = !dragStartEvent.canceled();
                if (this.dragging) {
                  document.addEventListener("contextmenu", this[onContextMenuWhileDragging]);
                  document.addEventListener("mousemove", this[onMouseMove]);
                }
              }, this.options.delay);
            }
            [onMouseMove](event) {
              if (!this.dragging) {
                return;
              }
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragMoveEvent);
            }
            [onMouseUp](event) {
              this.mouseDown = Boolean(this.openedContextMenu);
              if (this.openedContextMenu) {
                this.openedContextMenu = false;
                return;
              }
              document.removeEventListener("mouseup", this[onMouseUp]);
              document.removeEventListener("dragstart", preventNativeDragStart);
              if (!this.dragging) {
                return;
              }
              const target = document.elementFromPoint(event.clientX, event.clientY);
              const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                clientX: event.clientX,
                clientY: event.clientY,
                target,
                container: this.currentContainer,
                originalEvent: event
              });
              this.trigger(this.currentContainer, dragStopEvent);
              document.removeEventListener("contextmenu", this[onContextMenuWhileDragging]);
              document.removeEventListener("mousemove", this[onMouseMove]);
              this.currentContainer = null;
              this.dragging = false;
            }
            [onContextMenuWhileDragging](event) {
              event.preventDefault();
              this.openedContextMenu = true;
            }
          }
          exports2.default = MouseSensor;
          function preventNativeDragStart(event) {
            event.preventDefault();
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _MouseSensor = __webpack_require__(45);
          var _MouseSensor2 = _interopRequireDefault(_MouseSensor);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _MouseSensor2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          class Sensor {
            constructor(containers = [], options = {}) {
              this.containers = [...containers];
              this.options = _extends({}, options);
              this.dragging = false;
              this.currentContainer = null;
            }
            attach() {
              return this;
            }
            detach() {
              return this;
            }
            addContainer(...containers) {
              this.containers = [...this.containers, ...containers];
            }
            removeContainer(...containers) {
              this.containers = this.containers.filter((container) => !containers.includes(container));
            }
            trigger(element, sensorEvent) {
              const event = document.createEvent("Event");
              event.detail = sensorEvent;
              event.initEvent(sensorEvent.type, true, true);
              element.dispatchEvent(event);
              this.lastEvent = sensorEvent;
              return sensorEvent;
            }
          }
          exports2.default = Sensor;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = requestNextAnimationFrame;
          function requestNextAnimationFrame(callback) {
            return requestAnimationFrame(() => {
              requestAnimationFrame(callback);
            });
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _requestNextAnimationFrame = __webpack_require__(48);
          var _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _requestNextAnimationFrame2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = closest;
          const matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;
          function closest(element, value) {
            if (!element) {
              return null;
            }
            const selector = value;
            const callback = value;
            const nodeList = value;
            const singleElement = value;
            const isSelector = Boolean(typeof value === "string");
            const isFunction = Boolean(typeof value === "function");
            const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);
            const isElement = Boolean(value instanceof HTMLElement);
            function conditionFn(currentElement) {
              if (!currentElement) {
                return currentElement;
              } else if (isSelector) {
                return matchFunction.call(currentElement, selector);
              } else if (isNodeList) {
                return [...nodeList].includes(currentElement);
              } else if (isElement) {
                return singleElement === currentElement;
              } else if (isFunction) {
                return callback(currentElement);
              } else {
                return null;
              }
            }
            let current = element;
            do {
              current = current.correspondingUseElement || current.correspondingElement || current;
              if (conditionFn(current)) {
                return current;
              }
              current = current.parentNode;
            } while (current && current !== document.body && current !== document);
            return null;
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _closest = __webpack_require__(50);
          var _closest2 = _interopRequireDefault(_closest);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _closest2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = exports2.scroll = exports2.onDragStop = exports2.onDragMove = exports2.onDragStart = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _utils = __webpack_require__(2);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onDragStart = exports2.onDragStart = Symbol("onDragStart");
          const onDragMove = exports2.onDragMove = Symbol("onDragMove");
          const onDragStop = exports2.onDragStop = Symbol("onDragStop");
          const scroll = exports2.scroll = Symbol("scroll");
          const defaultOptions = exports2.defaultOptions = {
            speed: 6,
            sensitivity: 50,
            scrollableElements: []
          };
          class Scrollable extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this.currentMousePosition = null;
              this.scrollAnimationFrame = null;
              this.scrollableElement = null;
              this.findScrollableElementFrame = null;
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragMove] = this[onDragMove].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this[scroll] = this[scroll].bind(this);
            }
            attach() {
              this.draggable.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
            }
            detach() {
              this.draggable.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
            }
            getOptions() {
              return this.draggable.options.scrollable || {};
            }
            getScrollableElement(target) {
              if (this.hasDefinedScrollableElements()) {
                return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;
              } else {
                return closestScrollableElement(target);
              }
            }
            hasDefinedScrollableElements() {
              return Boolean(this.options.scrollableElements.length !== 0);
            }
            [onDragStart](dragEvent) {
              this.findScrollableElementFrame = requestAnimationFrame(() => {
                this.scrollableElement = this.getScrollableElement(dragEvent.source);
              });
            }
            [onDragMove](dragEvent) {
              this.findScrollableElementFrame = requestAnimationFrame(() => {
                this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);
              });
              if (!this.scrollableElement) {
                return;
              }
              const sensorEvent = dragEvent.sensorEvent;
              const scrollOffset = { x: 0, y: 0 };
              if ("ontouchstart" in window) {
                scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
              }
              this.currentMousePosition = {
                clientX: sensorEvent.clientX - scrollOffset.x,
                clientY: sensorEvent.clientY - scrollOffset.y
              };
              this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
            }
            [onDragStop]() {
              cancelAnimationFrame(this.scrollAnimationFrame);
              cancelAnimationFrame(this.findScrollableElementFrame);
              this.scrollableElement = null;
              this.scrollAnimationFrame = null;
              this.findScrollableElementFrame = null;
              this.currentMousePosition = null;
            }
            [scroll]() {
              if (!this.scrollableElement || !this.currentMousePosition) {
                return;
              }
              cancelAnimationFrame(this.scrollAnimationFrame);
              const { speed, sensitivity } = this.options;
              const rect = this.scrollableElement.getBoundingClientRect();
              const bottomCutOff = rect.bottom > window.innerHeight;
              const topCutOff = rect.top < 0;
              const cutOff = topCutOff || bottomCutOff;
              const documentScrollingElement = getDocumentScrollingElement();
              const scrollableElement = this.scrollableElement;
              const clientX = this.currentMousePosition.clientX;
              const clientY = this.currentMousePosition.clientY;
              if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
                const { offsetHeight, offsetWidth } = scrollableElement;
                if (rect.top + offsetHeight - clientY < sensitivity) {
                  scrollableElement.scrollTop += speed;
                } else if (clientY - rect.top < sensitivity) {
                  scrollableElement.scrollTop -= speed;
                }
                if (rect.left + offsetWidth - clientX < sensitivity) {
                  scrollableElement.scrollLeft += speed;
                } else if (clientX - rect.left < sensitivity) {
                  scrollableElement.scrollLeft -= speed;
                }
              } else {
                const { innerHeight, innerWidth } = window;
                if (clientY < sensitivity) {
                  documentScrollingElement.scrollTop -= speed;
                } else if (innerHeight - clientY < sensitivity) {
                  documentScrollingElement.scrollTop += speed;
                }
                if (clientX < sensitivity) {
                  documentScrollingElement.scrollLeft -= speed;
                } else if (innerWidth - clientX < sensitivity) {
                  documentScrollingElement.scrollLeft += speed;
                }
              }
              this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
            }
          }
          exports2.default = Scrollable;
          function hasOverflow(element) {
            const overflowRegex = /(auto|scroll)/;
            const computedStyles = getComputedStyle(element, null);
            const overflow = computedStyles.getPropertyValue("overflow") + computedStyles.getPropertyValue("overflow-y") + computedStyles.getPropertyValue("overflow-x");
            return overflowRegex.test(overflow);
          }
          function isStaticallyPositioned(element) {
            const position = getComputedStyle(element).getPropertyValue("position");
            return position === "static";
          }
          function closestScrollableElement(element) {
            if (!element) {
              return getDocumentScrollingElement();
            }
            const position = getComputedStyle(element).getPropertyValue("position");
            const excludeStaticParents = position === "absolute";
            const scrollableElement = (0, _utils.closest)(element, (parent) => {
              if (excludeStaticParents && isStaticallyPositioned(parent)) {
                return false;
              }
              return hasOverflow(parent);
            });
            if (position === "fixed" || !scrollableElement) {
              return getDocumentScrollingElement();
            } else {
              return scrollableElement;
            }
          }
          function getDocumentScrollingElement() {
            return document.scrollingElement || document.documentElement;
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _Scrollable = __webpack_require__(52);
          var _Scrollable2 = _interopRequireDefault(_Scrollable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Scrollable2.default;
          exports2.defaultOptions = _Scrollable.defaultOptions;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.MirrorDestroyEvent = exports2.MirrorMoveEvent = exports2.MirrorAttachedEvent = exports2.MirrorCreatedEvent = exports2.MirrorCreateEvent = exports2.MirrorEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class MirrorEvent extends _AbstractEvent2.default {
            get source() {
              return this.data.source;
            }
            get originalSource() {
              return this.data.originalSource;
            }
            get sourceContainer() {
              return this.data.sourceContainer;
            }
            get sensorEvent() {
              return this.data.sensorEvent;
            }
            get dragEvent() {
              return this.data.dragEvent;
            }
            get originalEvent() {
              if (this.sensorEvent) {
                return this.sensorEvent.originalEvent;
              }
              return null;
            }
          }
          exports2.MirrorEvent = MirrorEvent;
          class MirrorCreateEvent extends MirrorEvent {
          }
          exports2.MirrorCreateEvent = MirrorCreateEvent;
          MirrorCreateEvent.type = "mirror:create";
          class MirrorCreatedEvent extends MirrorEvent {
            get mirror() {
              return this.data.mirror;
            }
          }
          exports2.MirrorCreatedEvent = MirrorCreatedEvent;
          MirrorCreatedEvent.type = "mirror:created";
          class MirrorAttachedEvent extends MirrorEvent {
            get mirror() {
              return this.data.mirror;
            }
          }
          exports2.MirrorAttachedEvent = MirrorAttachedEvent;
          MirrorAttachedEvent.type = "mirror:attached";
          class MirrorMoveEvent extends MirrorEvent {
            get mirror() {
              return this.data.mirror;
            }
          }
          exports2.MirrorMoveEvent = MirrorMoveEvent;
          MirrorMoveEvent.type = "mirror:move";
          MirrorMoveEvent.cancelable = true;
          class MirrorDestroyEvent extends MirrorEvent {
            get mirror() {
              return this.data.mirror;
            }
          }
          exports2.MirrorDestroyEvent = MirrorDestroyEvent;
          MirrorDestroyEvent.type = "mirror:destroy";
          MirrorDestroyEvent.cancelable = true;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _MirrorEvent = __webpack_require__(54);
          Object.keys(_MirrorEvent).forEach(function(key) {
            if (key === "default" || key === "__esModule")
              return;
            Object.defineProperty(exports2, key, {
              enumerable: true,
              get: function() {
                return _MirrorEvent[key];
              }
            });
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = exports2.getAppendableContainer = exports2.onScroll = exports2.onMirrorMove = exports2.onMirrorCreated = exports2.onDragStop = exports2.onDragMove = exports2.onDragStart = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _MirrorEvent = __webpack_require__(55);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) {
              if (keys.indexOf(i) >= 0)
                continue;
              if (!Object.prototype.hasOwnProperty.call(obj, i))
                continue;
              target[i] = obj[i];
            }
            return target;
          }
          const onDragStart = exports2.onDragStart = Symbol("onDragStart");
          const onDragMove = exports2.onDragMove = Symbol("onDragMove");
          const onDragStop = exports2.onDragStop = Symbol("onDragStop");
          const onMirrorCreated = exports2.onMirrorCreated = Symbol("onMirrorCreated");
          const onMirrorMove = exports2.onMirrorMove = Symbol("onMirrorMove");
          const onScroll = exports2.onScroll = Symbol("onScroll");
          const getAppendableContainer = exports2.getAppendableContainer = Symbol("getAppendableContainer");
          const defaultOptions = exports2.defaultOptions = {
            constrainDimensions: false,
            xAxis: true,
            yAxis: true,
            cursorOffsetX: null,
            cursorOffsetY: null
          };
          class Mirror extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this.scrollOffset = { x: 0, y: 0 };
              this.initialScrollOffset = {
                x: window.scrollX,
                y: window.scrollY
              };
              this[onDragStart] = this[onDragStart].bind(this);
              this[onDragMove] = this[onDragMove].bind(this);
              this[onDragStop] = this[onDragStop].bind(this);
              this[onMirrorCreated] = this[onMirrorCreated].bind(this);
              this[onMirrorMove] = this[onMirrorMove].bind(this);
              this[onScroll] = this[onScroll].bind(this);
            }
            attach() {
              this.draggable.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]).on("mirror:created", this[onMirrorCreated]).on("mirror:move", this[onMirrorMove]);
            }
            detach() {
              this.draggable.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]).off("mirror:created", this[onMirrorCreated]).off("mirror:move", this[onMirrorMove]);
            }
            getOptions() {
              return this.draggable.options.mirror || {};
            }
            [onDragStart](dragEvent) {
              if (dragEvent.canceled()) {
                return;
              }
              if ("ontouchstart" in window) {
                document.addEventListener("scroll", this[onScroll], true);
              }
              this.initialScrollOffset = {
                x: window.scrollX,
                y: window.scrollY
              };
              const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;
              const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({
                source,
                originalSource,
                sourceContainer,
                sensorEvent,
                dragEvent
              });
              this.draggable.trigger(mirrorCreateEvent);
              if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
                return;
              }
              const appendableContainer = this[getAppendableContainer](source) || sourceContainer;
              this.mirror = source.cloneNode(true);
              const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({
                source,
                originalSource,
                sourceContainer,
                sensorEvent,
                dragEvent,
                mirror: this.mirror
              });
              const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({
                source,
                originalSource,
                sourceContainer,
                sensorEvent,
                dragEvent,
                mirror: this.mirror
              });
              this.draggable.trigger(mirrorCreatedEvent);
              appendableContainer.appendChild(this.mirror);
              this.draggable.trigger(mirrorAttachedEvent);
            }
            [onDragMove](dragEvent) {
              if (!this.mirror || dragEvent.canceled()) {
                return;
              }
              const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;
              const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({
                source,
                originalSource,
                sourceContainer,
                sensorEvent,
                dragEvent,
                mirror: this.mirror
              });
              this.draggable.trigger(mirrorMoveEvent);
            }
            [onDragStop](dragEvent) {
              if ("ontouchstart" in window) {
                document.removeEventListener("scroll", this[onScroll], true);
              }
              this.initialScrollOffset = { x: 0, y: 0 };
              this.scrollOffset = { x: 0, y: 0 };
              if (!this.mirror) {
                return;
              }
              const { source, sourceContainer, sensorEvent } = dragEvent;
              const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({
                source,
                mirror: this.mirror,
                sourceContainer,
                sensorEvent,
                dragEvent
              });
              this.draggable.trigger(mirrorDestroyEvent);
              if (!mirrorDestroyEvent.canceled()) {
                this.mirror.parentNode.removeChild(this.mirror);
              }
            }
            [onScroll]() {
              this.scrollOffset = {
                x: window.scrollX - this.initialScrollOffset.x,
                y: window.scrollY - this.initialScrollOffset.y
              };
            }
            [onMirrorCreated]({ mirror, source, sensorEvent }) {
              const mirrorClass = this.draggable.getClassNameFor("mirror");
              const setState = (_ref) => {
                let { mirrorOffset, initialX, initialY } = _ref, args = _objectWithoutProperties(_ref, ["mirrorOffset", "initialX", "initialY"]);
                this.mirrorOffset = mirrorOffset;
                this.initialX = initialX;
                this.initialY = initialY;
                return _extends({ mirrorOffset, initialX, initialY }, args);
              };
              const initialState = {
                mirror,
                source,
                sensorEvent,
                mirrorClass,
                scrollOffset: this.scrollOffset,
                options: this.options
              };
              return Promise.resolve(initialState).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);
            }
            [onMirrorMove](mirrorEvent) {
              if (mirrorEvent.canceled()) {
                return null;
              }
              const initialState = {
                mirror: mirrorEvent.mirror,
                sensorEvent: mirrorEvent.sensorEvent,
                mirrorOffset: this.mirrorOffset,
                options: this.options,
                initialX: this.initialX,
                initialY: this.initialY,
                scrollOffset: this.scrollOffset
              };
              return Promise.resolve(initialState).then(positionMirror({ raf: true }));
            }
            [getAppendableContainer](source) {
              const appendTo = this.options.appendTo;
              if (typeof appendTo === "string") {
                return document.querySelector(appendTo);
              } else if (appendTo instanceof HTMLElement) {
                return appendTo;
              } else if (typeof appendTo === "function") {
                return appendTo(source);
              } else {
                return source.parentNode;
              }
            }
          }
          exports2.default = Mirror;
          function computeMirrorDimensions(_ref2) {
            let { source } = _ref2, args = _objectWithoutProperties(_ref2, ["source"]);
            return withPromise((resolve) => {
              const sourceRect = source.getBoundingClientRect();
              resolve(_extends({ source, sourceRect }, args));
            });
          }
          function calculateMirrorOffset(_ref3) {
            let { sensorEvent, sourceRect, options } = _ref3, args = _objectWithoutProperties(_ref3, ["sensorEvent", "sourceRect", "options"]);
            return withPromise((resolve) => {
              const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
              const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
              const mirrorOffset = { top, left };
              resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));
            });
          }
          function resetMirror(_ref4) {
            let { mirror, source, options } = _ref4, args = _objectWithoutProperties(_ref4, ["mirror", "source", "options"]);
            return withPromise((resolve) => {
              let offsetHeight;
              let offsetWidth;
              if (options.constrainDimensions) {
                const computedSourceStyles = getComputedStyle(source);
                offsetHeight = computedSourceStyles.getPropertyValue("height");
                offsetWidth = computedSourceStyles.getPropertyValue("width");
              }
              mirror.style.position = "fixed";
              mirror.style.pointerEvents = "none";
              mirror.style.top = 0;
              mirror.style.left = 0;
              mirror.style.margin = 0;
              if (options.constrainDimensions) {
                mirror.style.height = offsetHeight;
                mirror.style.width = offsetWidth;
              }
              resolve(_extends({ mirror, source, options }, args));
            });
          }
          function addMirrorClasses(_ref5) {
            let { mirror, mirrorClass } = _ref5, args = _objectWithoutProperties(_ref5, ["mirror", "mirrorClass"]);
            return withPromise((resolve) => {
              mirror.classList.add(mirrorClass);
              resolve(_extends({ mirror, mirrorClass }, args));
            });
          }
          function removeMirrorID(_ref6) {
            let { mirror } = _ref6, args = _objectWithoutProperties(_ref6, ["mirror"]);
            return withPromise((resolve) => {
              mirror.removeAttribute("id");
              delete mirror.id;
              resolve(_extends({ mirror }, args));
            });
          }
          function positionMirror({ withFrame = false, initial = false } = {}) {
            return (_ref7) => {
              let { mirror, sensorEvent, mirrorOffset, initialY, initialX, scrollOffset, options } = _ref7, args = _objectWithoutProperties(_ref7, ["mirror", "sensorEvent", "mirrorOffset", "initialY", "initialX", "scrollOffset", "options"]);
              return withPromise((resolve) => {
                const result = _extends({
                  mirror,
                  sensorEvent,
                  mirrorOffset,
                  options
                }, args);
                if (mirrorOffset) {
                  const x = sensorEvent.clientX - mirrorOffset.left - scrollOffset.x;
                  const y = sensorEvent.clientY - mirrorOffset.top - scrollOffset.y;
                  if (options.xAxis && options.yAxis || initial) {
                    mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                  } else if (options.xAxis && !options.yAxis) {
                    mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;
                  } else if (options.yAxis && !options.xAxis) {
                    mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;
                  }
                  if (initial) {
                    result.initialX = x;
                    result.initialY = y;
                  }
                }
                resolve(result);
              }, { frame: withFrame });
            };
          }
          function withPromise(callback, { raf = false } = {}) {
            return new Promise((resolve, reject) => {
              if (raf) {
                requestAnimationFrame(() => {
                  callback(resolve, reject);
                });
              } else {
                callback(resolve, reject);
              }
            });
          }
          function isNativeDragEvent(sensorEvent) {
            return /^drag/.test(sensorEvent.originalEvent.type);
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _Mirror = __webpack_require__(56);
          var _Mirror2 = _interopRequireDefault(_Mirror);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Mirror2.default;
          exports2.defaultOptions = _Mirror.defaultOptions;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onInitialize = Symbol("onInitialize");
          const onDestroy = Symbol("onDestroy");
          const defaultOptions = {};
          class Focusable extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this[onInitialize] = this[onInitialize].bind(this);
              this[onDestroy] = this[onDestroy].bind(this);
            }
            attach() {
              this.draggable.on("draggable:initialize", this[onInitialize]).on("draggable:destroy", this[onDestroy]);
            }
            detach() {
              this.draggable.off("draggable:initialize", this[onInitialize]).off("draggable:destroy", this[onDestroy]);
            }
            getOptions() {
              return this.draggable.options.focusable || {};
            }
            getElements() {
              return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
            }
            [onInitialize]() {
              requestAnimationFrame(() => {
                this.getElements().forEach((element) => decorateElement(element));
              });
            }
            [onDestroy]() {
              requestAnimationFrame(() => {
                this.getElements().forEach((element) => stripElement(element));
              });
            }
          }
          exports2.default = Focusable;
          const elementsWithMissingTabIndex = [];
          function decorateElement(element) {
            const hasMissingTabIndex = Boolean(!element.getAttribute("tabindex") && element.tabIndex === -1);
            if (hasMissingTabIndex) {
              elementsWithMissingTabIndex.push(element);
              element.tabIndex = 0;
            }
          }
          function stripElement(element) {
            const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);
            if (tabIndexElementPosition !== -1) {
              element.tabIndex = -1;
              elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
            }
          }
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _Focusable = __webpack_require__(58);
          var _Focusable2 = _interopRequireDefault(_Focusable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Focusable2.default;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          class AbstractPlugin {
            constructor(draggable) {
              this.draggable = draggable;
            }
            attach() {
              throw new Error("Not Implemented");
            }
            detach() {
              throw new Error("Not Implemented");
            }
          }
          exports2.default = AbstractPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const onInitialize = Symbol("onInitialize");
          const onDestroy = Symbol("onDestroy");
          const announceEvent = Symbol("announceEvent");
          const announceMessage = Symbol("announceMessage");
          const ARIA_RELEVANT = "aria-relevant";
          const ARIA_ATOMIC = "aria-atomic";
          const ARIA_LIVE = "aria-live";
          const ROLE = "role";
          const defaultOptions = exports2.defaultOptions = {
            expire: 7e3
          };
          class Announcement extends _AbstractPlugin2.default {
            constructor(draggable) {
              super(draggable);
              this.options = _extends({}, defaultOptions, this.getOptions());
              this.originalTriggerMethod = this.draggable.trigger;
              this[onInitialize] = this[onInitialize].bind(this);
              this[onDestroy] = this[onDestroy].bind(this);
            }
            attach() {
              this.draggable.on("draggable:initialize", this[onInitialize]);
            }
            detach() {
              this.draggable.off("draggable:destroy", this[onDestroy]);
            }
            getOptions() {
              return this.draggable.options.announcements || {};
            }
            [announceEvent](event) {
              const message = this.options[event.type];
              if (message && typeof message === "string") {
                this[announceMessage](message);
              }
              if (message && typeof message === "function") {
                this[announceMessage](message(event));
              }
            }
            [announceMessage](message) {
              announce(message, { expire: this.options.expire });
            }
            [onInitialize]() {
              this.draggable.trigger = (event) => {
                try {
                  this[announceEvent](event);
                } finally {
                  this.originalTriggerMethod.call(this.draggable, event);
                }
              };
            }
            [onDestroy]() {
              this.draggable.trigger = this.originalTriggerMethod;
            }
          }
          exports2.default = Announcement;
          const liveRegion = createRegion();
          function announce(message, { expire }) {
            const element = document.createElement("div");
            element.textContent = message;
            liveRegion.appendChild(element);
            return setTimeout(() => {
              liveRegion.removeChild(element);
            }, expire);
          }
          function createRegion() {
            const element = document.createElement("div");
            element.setAttribute("id", "draggable-live-region");
            element.setAttribute(ARIA_RELEVANT, "additions");
            element.setAttribute(ARIA_ATOMIC, "true");
            element.setAttribute(ARIA_LIVE, "assertive");
            element.setAttribute(ROLE, "log");
            element.style.position = "fixed";
            element.style.width = "1px";
            element.style.height = "1px";
            element.style.top = "-1px";
            element.style.overflow = "hidden";
            return element;
          }
          document.addEventListener("DOMContentLoaded", () => {
            document.body.appendChild(liveRegion);
          });
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultOptions = void 0;
          var _Announcement = __webpack_require__(61);
          var _Announcement2 = _interopRequireDefault(_Announcement);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = _Announcement2.default;
          exports2.defaultOptions = _Announcement.defaultOptions;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DraggableDestroyEvent = exports2.DraggableInitializedEvent = exports2.DraggableEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class DraggableEvent extends _AbstractEvent2.default {
            get draggable() {
              return this.data.draggable;
            }
          }
          exports2.DraggableEvent = DraggableEvent;
          DraggableEvent.type = "draggable";
          class DraggableInitializedEvent extends DraggableEvent {
          }
          exports2.DraggableInitializedEvent = DraggableInitializedEvent;
          DraggableInitializedEvent.type = "draggable:initialize";
          class DraggableDestroyEvent extends DraggableEvent {
          }
          exports2.DraggableDestroyEvent = DraggableDestroyEvent;
          DraggableDestroyEvent.type = "draggable:destroy";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          const canceled = Symbol("canceled");
          class AbstractEvent {
            constructor(data) {
              this[canceled] = false;
              this.data = data;
            }
            get type() {
              return this.constructor.type;
            }
            get cancelable() {
              return this.constructor.cancelable;
            }
            cancel() {
              this[canceled] = true;
            }
            canceled() {
              return Boolean(this[canceled]);
            }
            clone(data) {
              return new this.constructor(_extends({}, this.data, data));
            }
          }
          exports2.default = AbstractEvent;
          AbstractEvent.type = "event";
          AbstractEvent.cancelable = false;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DragStopEvent = exports2.DragPressureEvent = exports2.DragOutContainerEvent = exports2.DragOverContainerEvent = exports2.DragOutEvent = exports2.DragOverEvent = exports2.DragMoveEvent = exports2.DragStartEvent = exports2.DragEvent = void 0;
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          class DragEvent extends _AbstractEvent2.default {
            get source() {
              return this.data.source;
            }
            get originalSource() {
              return this.data.originalSource;
            }
            get mirror() {
              return this.data.mirror;
            }
            get sourceContainer() {
              return this.data.sourceContainer;
            }
            get sensorEvent() {
              return this.data.sensorEvent;
            }
            get originalEvent() {
              if (this.sensorEvent) {
                return this.sensorEvent.originalEvent;
              }
              return null;
            }
          }
          exports2.DragEvent = DragEvent;
          DragEvent.type = "drag";
          class DragStartEvent extends DragEvent {
          }
          exports2.DragStartEvent = DragStartEvent;
          DragStartEvent.type = "drag:start";
          DragStartEvent.cancelable = true;
          class DragMoveEvent extends DragEvent {
          }
          exports2.DragMoveEvent = DragMoveEvent;
          DragMoveEvent.type = "drag:move";
          class DragOverEvent extends DragEvent {
            get overContainer() {
              return this.data.overContainer;
            }
            get over() {
              return this.data.over;
            }
          }
          exports2.DragOverEvent = DragOverEvent;
          DragOverEvent.type = "drag:over";
          DragOverEvent.cancelable = true;
          class DragOutEvent extends DragEvent {
            get overContainer() {
              return this.data.overContainer;
            }
            get over() {
              return this.data.over;
            }
          }
          exports2.DragOutEvent = DragOutEvent;
          DragOutEvent.type = "drag:out";
          class DragOverContainerEvent extends DragEvent {
            get overContainer() {
              return this.data.overContainer;
            }
          }
          exports2.DragOverContainerEvent = DragOverContainerEvent;
          DragOverContainerEvent.type = "drag:over:container";
          class DragOutContainerEvent extends DragEvent {
            get overContainer() {
              return this.data.overContainer;
            }
          }
          exports2.DragOutContainerEvent = DragOutContainerEvent;
          DragOutContainerEvent.type = "drag:out:container";
          class DragPressureEvent extends DragEvent {
            get pressure() {
              return this.data.pressure;
            }
          }
          exports2.DragPressureEvent = DragPressureEvent;
          DragPressureEvent.type = "drag:pressure";
          class DragStopEvent extends DragEvent {
          }
          exports2.DragStopEvent = DragStopEvent;
          DragStopEvent.type = "drag:stop";
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.Plugins = exports2.Sensors = exports2.Sortable = exports2.Swappable = exports2.Droppable = exports2.Draggable = exports2.BasePlugin = exports2.BaseEvent = void 0;
          var _Draggable = __webpack_require__(5);
          Object.defineProperty(exports2, "Draggable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Draggable).default;
            }
          });
          var _Droppable = __webpack_require__(34);
          Object.defineProperty(exports2, "Droppable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Droppable).default;
            }
          });
          var _Swappable = __webpack_require__(31);
          Object.defineProperty(exports2, "Swappable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Swappable).default;
            }
          });
          var _Sortable = __webpack_require__(28);
          Object.defineProperty(exports2, "Sortable", {
            enumerable: true,
            get: function() {
              return _interopRequireDefault(_Sortable).default;
            }
          });
          var _AbstractEvent = __webpack_require__(0);
          var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
          var _AbstractPlugin = __webpack_require__(1);
          var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
          var _Sensors = __webpack_require__(6);
          var Sensors = _interopRequireWildcard(_Sensors);
          var _Plugins = __webpack_require__(25);
          var Plugins = _interopRequireWildcard(_Plugins);
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.BaseEvent = _AbstractEvent2.default;
          exports2.BasePlugin = _AbstractPlugin2.default;
          exports2.Sensors = Sensors;
          exports2.Plugins = Plugins;
        }
      ]);
    });
  }
});

// dep:@shopify_draggable
var shopify_draggable_default = require_draggable_bundle();
export {
  shopify_draggable_default as default
};
//# sourceMappingURL=@shopify_draggable.js.map
